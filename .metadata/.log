!SESSION 2019-06-24 08:41:24.901 -----------------------------------------------
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.epp.logging.aeri.ide 2 16 2019-06-24 08:42:08.014
!MESSAGE Server ‘org.eclipse.epp.logging.aeri.ide.server’ failed with exception: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target. ; version: 1.100.0.v20160217-0435
!STACK 0
javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.ssl.Alerts.getSSLException(Unknown Source)
	at sun.security.ssl.SSLSocketImpl.fatal(Unknown Source)
	at sun.security.ssl.Handshaker.fatalSE(Unknown Source)
	at sun.security.ssl.Handshaker.fatalSE(Unknown Source)
	at sun.security.ssl.ClientHandshaker.serverCertificate(Unknown Source)
	at sun.security.ssl.ClientHandshaker.processMessage(Unknown Source)
	at sun.security.ssl.Handshaker.processLoop(Unknown Source)
	at sun.security.ssl.Handshaker.process_record(Unknown Source)
	at sun.security.ssl.SSLSocketImpl.readRecord(Unknown Source)
	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(Unknown Source)
	at sun.security.ssl.SSLSocketImpl.startHandshake(Unknown Source)
	at sun.security.ssl.SSLSocketImpl.startHandshake(Unknown Source)
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:290)
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:259)
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:125)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:319)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:206)
	at org.eclipse.epp.internal.logging.aeri.ide.server.mars.IO.request(IO.java:205)
	at org.eclipse.epp.internal.logging.aeri.ide.server.mars.IO.refreshConfiguration(IO.java:68)
	at org.eclipse.epp.internal.logging.aeri.ide.server.mars.ServerConnection.startUp(ServerConnection.java:101)
	at com.google.common.util.concurrent.AbstractIdleService$2$1.run(AbstractIdleService.java:54)
	at com.google.common.util.concurrent.Callables$3.run(Callables.java:93)
	at java.lang.Thread.run(Unknown Source)
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.validator.PKIXValidator.doBuild(Unknown Source)
	at sun.security.validator.PKIXValidator.engineValidate(Unknown Source)
	at sun.security.validator.Validator.validate(Unknown Source)
	at sun.security.ssl.X509TrustManagerImpl.validate(Unknown Source)
	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(Unknown Source)
	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(Unknown Source)
	... 27 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
	at sun.security.provider.certpath.SunCertPathBuilder.build(Unknown Source)
	at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(Unknown Source)
	at java.security.cert.CertPathBuilder.build(Unknown Source)
	... 33 more

!ENTRY org.eclipse.egit.ui 2 0 2019-06-24 08:44:19.381
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 10:06:28.565
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.connector.basic.ArtifactTransportListener.transferFailed(ArtifactTransportListener.java:43)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.run(BasicRepositoryConnector.java:355)
	at org.eclipse.aether.util.concurrency.RunnableErrorForwarder$1.run(RunnableErrorForwarder.java:67)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$DirectExecutor.execute(BasicRepositoryConnector.java:581)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector.get(BasicRepositoryConnector.java:249)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:520)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more
Caused by: java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:198)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:178)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:137)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:150)
	at org.eclipse.aether.spi.connector.transport.AbstractTransporter.copy(AbstractTransporter.java:200)
	at org.eclipse.aether.spi.connector.transport.AbstractTransporter.utilGet(AbstractTransporter.java:96)
	at org.eclipse.aether.transport.http.HttpTransporter.access$100(HttpTransporter.java:72)
	at org.eclipse.aether.transport.http.HttpTransporter$EntityGetter.handle(HttpTransporter.java:516)
	at org.eclipse.aether.transport.http.HttpTransporter.execute(HttpTransporter.java:294)
	at org.eclipse.aether.transport.http.HttpTransporter.implGet(HttpTransporter.java:243)
	at org.eclipse.aether.spi.connector.transport.AbstractTransporter.get(AbstractTransporter.java:59)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$GetTaskRunner.runTask(BasicRepositoryConnector.java:447)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.run(BasicRepositoryConnector.java:350)
	... 13 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 10:06:28.567
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 10:06:30.197
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 10:06:30.203
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 10:06:30.211
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 10:06:30.216
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.recommenders.rcp 2 23 2019-06-24 10:53:31.407
!MESSAGE Failed to parse news feed
!STACK 0
org.apache.http.conn.HttpHostConnectException: Connect to www.codetrails.com:443 [www.codetrails.com/78.46.211.228] failed: Connection timed out: connect
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:142)
	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:319)
	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:363)
	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:219)
	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:195)
	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:86)
	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:108)
	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:184)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)
	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:57)
	at org.apache.http.client.fluent.Executor.execute(Executor.java:206)
	at org.eclipse.recommenders.internal.rcp.news.CheckForProjectNewsJob.getRSSFeed(CheckForProjectNewsJob.java:138)
	at org.eclipse.recommenders.internal.rcp.news.CheckForProjectNewsJob.doRun(CheckForProjectNewsJob.java:89)
	at org.eclipse.recommenders.internal.rcp.news.CheckForProjectNewsJob.run(CheckForProjectNewsJob.java:62)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: java.net.ConnectException: Connection timed out: connect
	at java.net.DualStackPlainSocketImpl.connect0(Native Method)
	at java.net.DualStackPlainSocketImpl.socketConnect(Unknown Source)
	at java.net.AbstractPlainSocketImpl.doConnect(Unknown Source)
	at java.net.AbstractPlainSocketImpl.connectToAddress(Unknown Source)
	at java.net.AbstractPlainSocketImpl.connect(Unknown Source)
	at java.net.PlainSocketImpl.connect(Unknown Source)
	at java.net.SocksSocketImpl.connect(Unknown Source)
	at java.net.Socket.connect(Unknown Source)
	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:244)
	at org.apache.http.impl.conn.HttpClientConnectionOperator.connect(HttpClientConnectionOperator.java:125)
	... 14 more
!SESSION 2019-06-24 12:49:04.797 -----------------------------------------------
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-06-24 12:52:02.044
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:18:52.535
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.connector.basic.ArtifactTransportListener.transferFailed(ArtifactTransportListener.java:43)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.run(BasicRepositoryConnector.java:355)
	at org.eclipse.aether.util.concurrency.RunnableErrorForwarder$1.run(RunnableErrorForwarder.java:67)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$DirectExecutor.execute(BasicRepositoryConnector.java:581)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector.get(BasicRepositoryConnector.java:249)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:520)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more
Caused by: java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.socketRead(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at java.net.SocketInputStream.read(Unknown Source)
	at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:198)
	at org.apache.http.impl.io.ContentLengthInputStream.read(ContentLengthInputStream.java:178)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:137)
	at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:150)
	at org.eclipse.aether.spi.connector.transport.AbstractTransporter.copy(AbstractTransporter.java:200)
	at org.eclipse.aether.spi.connector.transport.AbstractTransporter.utilGet(AbstractTransporter.java:96)
	at org.eclipse.aether.transport.http.HttpTransporter.access$100(HttpTransporter.java:72)
	at org.eclipse.aether.transport.http.HttpTransporter$EntityGetter.handle(HttpTransporter.java:516)
	at org.eclipse.aether.transport.http.HttpTransporter.execute(HttpTransporter.java:294)
	at org.eclipse.aether.transport.http.HttpTransporter.implGet(HttpTransporter.java:243)
	at org.eclipse.aether.spi.connector.transport.AbstractTransporter.get(AbstractTransporter.java:59)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$GetTaskRunner.runTask(BasicRepositoryConnector.java:447)
	at org.eclipse.aether.connector.basic.BasicRepositoryConnector$TaskRunner.run(BasicRepositoryConnector.java:350)
	... 13 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:18:52.550
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:18:52.550
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:18:52.550
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:18:52.550
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:18:52.566
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:18:52.582
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:18:52.582
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:18:52.582
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:18:52.597
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:18:52.597
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:18:52.597
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:19:12.956
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:19:12.956
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:19:17.355
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:19:17.355
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:19:21.209
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:19:21.209
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?

!ENTRY org.eclipse.m2e.logback.appender 2 0 2019-06-24 16:19:39.306
!MESSAGE Failed to download jre:jre:ctor:zip:1.0.0
!STACK 0
org.eclipse.aether.resolution.ArtifactResolutionException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:444)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifacts(DefaultArtifactResolver.java:246)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolveArtifact(DefaultArtifactResolver.java:223)
	at org.eclipse.aether.internal.impl.DefaultRepositorySystem.resolveArtifact(DefaultRepositorySystem.java:294)
	at org.eclipse.recommenders.models.ModelRepository.resolveInternal(ModelRepository.java:192)
	at org.eclipse.recommenders.models.ModelRepository.resolve(ModelRepository.java:174)
	at org.eclipse.recommenders.internal.models.rcp.EclipseModelRepository.resolve(EclipseModelRepository.java:165)
	at org.eclipse.recommenders.internal.models.rcp.DownloadModelArchiveJob.run(DownloadModelArchiveJob.java:76)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
Caused by: org.eclipse.aether.transfer.ArtifactTransferException: Failure to transfer jre:jre:zip:ctor:1.0.0-20150616.145022-6 from http://download.eclipse.org/recommenders/models/mars/ was cached in the local repository, resolution will not be reattempted until the update interval of models has elapsed or updates are forced. Original error: Could not transfer artifact jre:jre:zip:ctor:1.0.0-20150616.145022-6 from/to models (http://download.eclipse.org/recommenders/models/mars/): Read timed out
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.newException(DefaultUpdateCheckManager.java:238)
	at org.eclipse.aether.internal.impl.DefaultUpdateCheckManager.checkArtifact(DefaultUpdateCheckManager.java:206)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.gatherDownloads(DefaultArtifactResolver.java:585)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.performDownloads(DefaultArtifactResolver.java:503)
	at org.eclipse.aether.internal.impl.DefaultArtifactResolver.resolve(DefaultArtifactResolver.java:421)
	... 8 more

!ENTRY org.eclipse.recommenders.models.rcp 1 0 2019-06-24 16:19:39.306
!MESSAGE jre:jre:ctor:zip:1.0.0 could not be resolved from the model repositories. Are you offline?
!SESSION 2019-06-25 08:34:14.641 -----------------------------------------------
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2019-06-25 08:39:09.694
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-06-25 08:39:09.694
!MESSAGE Could not read metadata for 'singleClient'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'singleClient' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:902)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:882)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:733)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1588)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2386)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2157)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:463)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318)
	at org.eclipse.osgi.container.Module.doStart(Module.java:571)
	at org.eclipse.osgi.container.Module.start(Module.java:439)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:140)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-06-25 08:39:09.694
!MESSAGE The project description file (.project) for 'singleClient' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-06-25 08:39:09.694
!MESSAGE Could not read metadata for 'singleServer'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'singleServer' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:902)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:882)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:733)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1588)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2386)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2157)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:463)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318)
	at org.eclipse.osgi.container.Module.doStart(Module.java:571)
	at org.eclipse.osgi.container.Module.start(Module.java:439)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:140)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-06-25 08:39:09.694
!MESSAGE The project description file (.project) for 'singleServer' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 2 0 2019-06-25 08:39:38.576
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-06-25 10:53:16.358 -----------------------------------------------
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.equinox.p2.publisher.eclipse 4 0 2019-06-25 10:53:29.898
!MESSAGE Unable to acquire PluginConverter service during generation for: C:\opensource\eclipse\plugins\configuration.

!ENTRY org.eclipse.equinox.p2.publisher.eclipse 4 0 2019-06-25 10:53:29.976
!MESSAGE Unable to acquire PluginConverter service during generation for: C:\opensource\eclipse\plugins\configuration.

!ENTRY org.eclipse.egit.ui 2 0 2019-06-25 10:53:43.134
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.230
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.296
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.299
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.379
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.383
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.389
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.407
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.411
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.414
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.425
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.427
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.430
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.441
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.442
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.444
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.454
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.456
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.458
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.469
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.471
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.473
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.483
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.485
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.487
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.497
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.499
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.500
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.511
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.513
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.515
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.524
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.526
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.528
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.536
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.539
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.540
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.551
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.552
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.554
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.564
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.566
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.568
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.577
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.579
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.581
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:55.590
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:55.592
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:55.593
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.core 4 4 2019-06-25 11:23:56.132
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package singleServer;

import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import java.net.*;
import java.io.*;
import org.eclipse.swt.widgets.Label;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Text;
import org.eclipse.wb.swt.SWTResourceManager;


import org.eclipse.swt.widgets.List;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import java.util.Vector;

public class ServerApp {

	protected Shell shell;
	private Text textPort;
	List list;
	ServerSocket server = null;

	private char connFlag='F';
	private Text textManager;
	private Text textArea;
	static Vector<Client> userList = new Vector<Client>();
	private char flag = 'T';
	private String[] fFile;
	/**
	 * Launch the application.
	 * @param args
	 */
	// 内部类 client
	class Client extends Thread{
		BufferedReader cin = null;
		DataInputStream fin = null;
		PrintStream cout = null;
		PrintStream fout = null;
		Socket s;
		Socket f;
		String username;
		public void appendTA(String str)
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					textArea.append(str);
				}
				
			});			
		}
	
		public Client(Socket s,Socket f)
		{
			this.s = s;
			this.f = f;
			try{
				cin = new BufferedReader(new InputStreamReader(this.s.getInputStream()));
				fin = new DataInputStream(new BufferedInputStream(this.f.getInputStream()));
				cout = new PrintStream(this.s.getOutputStream());
				fout = new PrintStream(this.f.getOutputStream());
				String str =cin.readLine();
				username = str;
				textArea.append(username+"已连接\n");
				
			}catch(IOException e)
			{
				textArea.append("用户连接出错");
			}
			
		}

		//method
		public void send(String msg){
			cout.println(msg);
			cout.flush(); // 清空缓冲区数据
			
		}
		public void run() {
			String fd = null;
			while(true)
			{
				if(flag!='F')
				{
					String str =null;
					try{
						str = cin.readLine();
					}catch(IOException e)
					{
						appendTA("读取客户信息错误");
						disconnect(this);
						return;
					}
					if(str.equalsIgnoreCase("EXIT"))
					{
						disconnect(this);
						this.stop();
					}
					else if(str.contains("SendFileByte"))
					{
						fFile = str.substring(12).split("#");
						fd = str;
						flag ='F';
					}
					else{
						if(flag!='G')
						{
							this.appendTA(str+"\n");
							Client conns;
							for(int i=0;i<userList.size();i++)
							{
								conns = (Client) userList.elementAt(i);
								conns.send(str);
							}
						}
						else
							flag='T';
					}
				}else{
					String savePath = SaveFile(fin,fFile[1],Integer.parseInt(fFile[2]));
					SendFile(savePath,fFile[1],Integer.parseInt(fFile[2]),fd);
					Client conn = GetClient(fFile[3]);
					conn.send(fFile[1]+"已发送至用用户"+fFile[0]);
					flag='G';
				}
				
			}
		}




		
	}
	// 内部类 connect
	class ConnectSocket extends Thread{
		public void appendformation()
		{
			Display.getDefault().syncExec(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					Client conn = new Client(socket,filesocket);
					userList.addElement(conn);
					String username = conn.username.substring(conn.username.indexOf(":")+1);
					if(list.indexOf(username)<0)
					{
						conn.start();
						list.add(username);
						Client conns;
						for(int i=0;i<userList.size();i++)
						{
							conns = (Client) userList.elementAt(i);
							conns.send("listusernames"+getlistname());
						}
					}
				}
				
			});
		}

		Socket socket;
		Socket filesocket;
		public void run(){
			while(true){
				try{
					socket = server.accept();
					filesocket = server.accept();
				}
				catch(IOException e2)
				{
					textArea.append("客户连接失败\n");
				}this.appendformation();
			}
		}
	}
	public static void main(String[] args) {
		try {
			ServerApp window = new ServerApp();
			window.open();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Open the window.
	 */
	public void open() {
		Display display = Display.getDefault();
		createContents();
		shell.open();
		shell.layout();
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch()) {
				display.sleep();
			}
		}
	}
	/**
	 * Create method
	 */
	
	// 断开连接
	public void disconnect(Client conn){
		String username =  conn.username.substring(conn.username.indexOf(":")+1);
		Display.getDefault().syncExec(new Runnable(){

			@Override
			public void run() {
				// TODO Auto-generated method stub
				textArea.append(username+"断开连接\n");
				if(list.indexOf(username)>=0)
				{
					list.remove(list.indexOf(username));
				}
			}
		});
		conn.send("退出");
		userList.removeElement(conn);
		try{
			conn.s.close();
		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
		Client conns;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			conns.send("listusernames"+getlistname());
		}
	}
	// GET 列表用户名单
	public String getlistname()
	{
		Client conns;
		String str="";
		String[] strs;
		for(int i=0;i<userList.size();i++)
		{
			conns = (Client) userList.elementAt(i);
			strs = conns.username.split(":");
			str=str+strs[1]+":";
		}
		return str;
	}
	public void SendFile(String savePath,String filename,int filelen,String line)
	{ 
		int len=1; 
		byte[] buf = new byte[filelen]; 
		try{ 
			DataInputStream fis = new DataInputStream(new BufferedInputStream(new FileInputStream(savePath))); 
			Client c=GetClient(fFile[0]);
			c.send(line);
			while ((len = fis.read(buf,0,buf.length)) > 0) 
			{ 
				c.fout.write(buf,0,len);
				c.fout.flush(); 
			}
			fis.close();
			deleteFile(savePath); 
		}
		catch(Exception e){
				e.printStackTrace();
			} 
	}
	// 保存文件
	public String SaveFile(DataInputStream gsm,String filename,int filelen)
	{
		int len = 1;
//		System.out.println(System.getProperty("user.dir"));
		
		String savePath = ".\\server\\"+filename;
		File testFile = new File(".\\server");
		if(!testFile.exists())
			testFile.mkdirs();
		File f = new File(savePath);
		byte[] buf = new byte[filelen];
		try{
			FileOutputStream in = new FileOutputStream(f);
			while((len=gsm.read(buf,0,buf.length))>0)
			{
				in.write(buf,0,len);
				in.flush();
				if(f.length()>=filelen)
				{
					break;
				}
			}
			in.close();
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return savePath;
		
	}
	
	// 删除文件
	public boolean deleteFile(String path)
	{
		File f = new File(path);
		if(f.isFile() && f.exists()){
			f.delete();
			return true;
		}
		return false;
	}
	// getClient
	
	private Client GetClient(String username) {
		// TODO Auto-generated method stub
		for(int i=0;i<userList.size();i++)
		{
			Client conn = (Client) userList.elementAt(i);
			if(username.equals(conn.username.substring(conn.username.indexOf(":")+1)));
				return conn;
		}
		
		return null;
	}
	
	/**
	 * Create contents of the window.
	 */
	
	
	protected void createContents() {
		shell = new Shell();
		shell.setModified(true);
		shell.setSize(450, 300);
		shell.setText("SWT Application");
		shell.setLayout(null);
		
		Label label = new Label(shell, SWT.NONE);
		label.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		label.setBounds(10, 10, 64, 23);
		label.setText("监听端口");
		
		textPort = new Text(shell, SWT.BORDER);
		textPort.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textPort.setBounds(80, 11, 258, 23);
		
		Button btnStart = new Button(shell, SWT.NONE);
		btnStart.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(textPort.getText()=="")
				{
					textArea.append("端口参数不能为空\n");
					return;
				}
				if(connFlag=='F')
				{					
					try{
						server = new ServerSocket(Integer.parseInt(textPort.getText()));
						textArea.append("服务器端口打开成功\n");
						btnStart.setText("关闭端口");
						connFlag='T';
					}catch(IOException e1)
					{
						textArea.append("服务器端口打开错误\n");
					}
					if(server == null)
					{
						textArea.append("端口为空\n");
						return;
					}
					ConnectSocket conn = new ConnectSocket();
					conn.start();
				}else{
					try {
						server.close();
						textArea.append("服务器端口关闭成功\n");
						btnStart.setText("开始监听");
						connFlag='F';
					} catch (IOException e1) {
						// TODO Auto-generated catch block
						textArea.append("服务器端口关闭错误\n");
					}
					
				}
			}
		});

		btnStart.setBounds(344, 9, 80, 27);
		btnStart.setText("开始监听");
		
		textManager = new Text(shell, SWT.BORDER);
		textManager.setFont(SWTResourceManager.getFont("微软雅黑", 12, SWT.NORMAL));
		textManager.setBounds(10, 45, 328, 23);
		
		Button btnSend = new Button(shell, SWT.NONE);
		btnSend.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				
				if(list.getSelectionIndex()>=0){
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						c.send("服务端："+textManager.getText());
						textArea.append("服务端："+textManager.getText()+"\n");
				}else{
					for(int i=0;i<list.getSelectionIndex();)
				}
				
			}
		});
		btnSend.setText("发送信息");
		btnSend.setBounds(344, 41, 80, 27);
		
		list = new List(shell, SWT.BORDER);
		list.setBounds(10, 97, 80, 122);
		Button btnKick = new Button(shell, SWT.NONE);
		btnKick.addSelectionListener(new SelectionAdapter() {
			@Override
			public void widgetSelected(SelectionEvent e) {
				if(list.getSelectionIndex()>=0)
				{
					Client c = GetClient(list.getSelection()[0]);
					if(c!=null)
						disconnect(c);
				}
			}
		});
		btnKick.setText("断开用户");
		btnKick.setBounds(10, 225, 80, 27);
		
		Label label_1 = new Label(shell, SWT.NONE);
		label_1.setBounds(20, 74, 61, 17);
		label_1.setText("用户列表");
		
		textArea = new Text(shell, SWT.BORDER | SWT.READ_ONLY | SWT.V_SCROLL);
		textArea.setBounds(96, 97, 328, 155);

	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 2 2019-06-25 11:23:56.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)

!ENTRY org.eclipse.jdt.ui 4 0 2019-06-25 11:23:56.137
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2511)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1696)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2751)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1216)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
!SESSION 2019-06-26 10:27:17.455 -----------------------------------------------
eclipse.buildId=4.5.2.M20160212-1500
java.version=1.8.0_111
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=zh_CN
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2019-06-26 10:39:03.715
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-06-26 10:39:03.715
!MESSAGE Could not read metadata for 'singleClient'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'singleClient' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:902)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:882)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:733)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1588)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2386)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2157)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:463)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318)
	at org.eclipse.osgi.container.Module.doStart(Module.java:571)
	at org.eclipse.osgi.container.Module.start(Module.java:439)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:140)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-06-26 10:39:03.715
!MESSAGE The project description file (.project) for 'singleClient' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2019-06-26 10:39:03.715
!MESSAGE Could not read metadata for 'singleServer'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'singleServer' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:902)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:882)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:733)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1588)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2386)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2157)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:463)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318)
	at org.eclipse.osgi.container.Module.doStart(Module.java:571)
	at org.eclipse.osgi.container.Module.start(Module.java:439)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:140)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2019-06-26 10:39:03.715
!MESSAGE The project description file (.project) for 'singleServer' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 2 0 2019-06-26 10:39:19.381
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\User'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2019-06-26 10:39:38.388
!MESSAGE Unable to create part
!SUBENTRY 1 org.eclipse.ui 4 0 2019-06-26 10:39:38.388
!MESSAGE Factory org.eclipse.jdt.ui.ClassFileEditorInputFactory returned null from createElement for editor id=org.eclipse.jdt.ui.ClassFileEditor name=null
